URLS=[
"docs/index.html",
"docs/custom_types.html",
"docs/datetime_conversions.html",
"docs/error_handler.html",
"docs/extensions/index.html",
"docs/extensions/absolutely_all.html",
"docs/extensions/admin.html",
"docs/session.html",
"docs/extensions/advanced_search.html",
"docs/extensions/commands.html",
"docs/extensions/flarum/index.html",
"docs/extensions/flarum/Askvortsov_ModeratorWarnings.html",
"docs/extensions/flarum/Askvortsov_ReplyTemplates.html",
"docs/extensions/flarum/Blomstra_Realtime.html",
"docs/extensions/flarum/Flarum_Approval.html",
"docs/extensions/flarum/Flarum_Flags.html",
"docs/extensions/flarum/Flarum_Likes.html",
"docs/extensions/flarum/Flarum_Lock.html",
"docs/extensions/flarum/Flarum_Markdown.html",
"docs/extensions/flarum/Flarum_Sticky.html",
"docs/extensions/flarum/Flarum_Subscriptions.html",
"docs/flarum/core/discussions.html",
"docs/extensions/flarum/Flarum_Suspend.html",
"docs/extensions/flarum/Flarum_Tags.html",
"docs/extensions/flarum/FoF_BestAnswer.html",
"docs/extensions/flarum/FoF_Byobu.html",
"docs/extensions/flarum/FoF_Merge.html",
"docs/extensions/flarum/FoF_PreventNecrobumping.html",
"docs/extensions/flarum/FoF_Spamblock.html",
"docs/extensions/flarum/FoF_Split.html",
"docs/extensions/flarum/FoF_UserBio.html",
"docs/extensions/flarum/FoF_UsernameRequest.html",
"docs/extensions/flarum/Malago_Achievements.html",
"docs/extensions/watch.html",
"docs/flarum/index.html",
"docs/flarum/core/index.html",
"docs/flarum/core/filters.html",
"docs/flarum/core/forum.html",
"docs/flarum/core/groups.html",
"docs/flarum/core/notifications.html",
"docs/flarum/core/posts.html",
"docs/flarum/core/users.html"
];
INDEX=[
{
"ref":"pyflarum",
"url":0,
"doc":" \ud83d\udc0d pyFlarum ![GitHub issues](https: img.shields.io/github/issues/CWKevo/pyflarum?color=forestgreen&label=Issues) ![GitHub](https: img.shields.io/github/license/CWKevo/pyFlarum?color=yellow&label=License) Somewhere at the beginning of this year, I have started a concept to build a Python Flarum API client. The goal was to provide everyone an easy and extensible system to interact with Flarum's public API and perform user-related tasks. Later, I began to work on rebasing FreeFlarum's code, so this idea was left in the dust. But after that was done, I revisited this project and started over now that I had learned more about Python. Thus, I present to you my first (real) Python package - [pyFlarum](https: pypi.org/project/pyFlarum).  \ud83d\udd17 Useful links: - [\ud83d\udde3 Discuss](https: discuss.flarum.org/d/28221) - [\ud83d\udcda Documentation](https: cwkevo.github.io/pyflarum/docs/) - [\ud83d\udc68\u200d\ud83d\udcbb GitHub repository](https: github.com/CWKevo/pyflarum) - [\ud83d\udc0d PyPi link](https: pypi.org/project/pyFlarum)  \ud83d\udc31\u200d\ud83c\udfcd Features: - Complete support for creating, retrieving, updating and deleting data. - (Almost) everything is object-oriented, with docstrings (still needs to be done) and examples to help you code faster. - Very extensible, thanks to custom extension & dependency system. The most common Flarum extensions are included out of the box, and more are still on the way. Read more about the extension system [here](https: cwkevo.github.io/pyflarum/docs/ extensions). - The data is fetched and stored as JSON, but the keys can be retrieved by using class properties, which also handles type conversions. - This means that instead of using  discussion['data']['attributes']['title'] , it is as simple as  discussion.title . - Flarum's JSON API works in saving mode. What I mean is that when you fetch a discussion from notification, not all of the discussion's data is present in the JSON. On the other hand, obtaining the discussion directly by it's ID results in a much detailed JSON. - To save you headaches, pyFlarum obviously handles this too and all of the objects have different hierarchy and inheritance. Example:  DiscussionFromNotification is parent for  DiscussionFromBulk and that's parent for  Discussion , where  Discussion object is discussion obtained directly from API, and therefore logically contains all properties of the previous objects (and JSON). This is all nicely rendered thanks to your editor's linting and type hints, so you won't make a mistake by accessing unexisting properties from parent objects. More about pyFlarum's inheritance system and it's flaws can be found [here](https: cwkevo.github.io/pyflarum/docs/ class-inheritance).  \ud83d\ude80 Quickstart:  \ud83d\udcc0 Installation: This package requires Python 3.6+ and the [requests](https: pypi.org/project/requests) library to be installed. Yep, that's the only dependency. Should there be more over time, you can install them all at once by using this command (but I assume that you're already familiar with all of this, so feel free to skip this part):   pip install -r requirements.txt  or: python -m pip install -r requirements.txt   Installing is easy with:   pip install pyflarum -U  or: python -m pip install pyflarum -U   Updating:   python -m pip install pyflarum -U  upgrade  or: pip install pyflarum  upgrade -U   Uninstalling:   python -m pip uninstall pyflarum  or: pip uninstall pyflarum    \ud83d\udcdc Quickstart Example: How easy is it to fetch a specific discussion and print it's title? The answer - luckily, it's actually quite easy:   from pyflarum import FlarumUser  Here, we initialize our  FlarumUser object. You can't do anything without this first: USER = FlarumUser(forum_url=\"https: discuss.flarum.org\")   forum_url parameter mustn't end with a slash, or it chokes on API URLs!  Now, let's get the discussion: discussion = USER.get_discussion_by_id(28221) print(discussion.title)   That's just amazing 4 lines of code (without comments and newlines)!  \u27a1 What's next? Check the [documentation](https: cwkevo.github.io/pyflarum/docs/) to dive deep into the concepts of this project and learn more! I will now take a small break from maintaining this - I still want to do a bit more projects this summer now that I have some time. However, I am open for feature requests and bug reports at the [GitHub repository](https: github.com/CWKevo/pyflarum/issues). The documentation is still not finished yet, but that can wait for now until some people show some interest in this. My honest view is that I do not want to work on something that people will not enjoy, and I will likely require some motivation in order to keep this project alive. If no interest is shown, I will occassionaly push bugfixes and features for my personal use over time. I don't actually expect much people to use this, but I'd be surprised and happy if you would!  \ud83d\udcdc Examples: I'll show you some more examples before we dive deep into the details at the [documentation](https: cwkevo.github.io/pyflarum/docs/). All of the following snippets assume that you already have your  USER object initialized. Get all discussions from the front page ( /api/discussions ) and print the title & URL:   for discussion in USER.all_discussions(): print(discussion.title, discussion.url)   Obtain some user:   user = USER.get_user_by_id(1) for group in user.get_groups(): print(group.nameSingular)   You can find more examples in the sections below, or browse the [tests](https: github.com/CWKevo/pyflarum/tree/main/tests) directory of the source code for full examples of various tasks. These will be regularly updated, [should this stay maintained]( \u27a1-whats-next), to ensure that old stuff works and new features behave correctly too.  \ud83d\udce1 Parameters By default, pyFlarum works by just knowing the forum's URL. But there are more options to choose from. Let's go through the basic ones:  \ud83d\udd10 Authentication In order to perform user related actions, you must be logged in. This is easier done than said (pun unintended):   USER = FlarumUser(forum_url=\"https: discuss.flarum.org\", username=\"yourusername\", password=\" TopSecret123\")    .just like that! However, I  strongly recommend you to store your user's credentials in a  .env file and load it by using a library such as [python-dotenv](https: pypi.org/project/python-dotenv):  .env:   username=\"foo\" password=\"hahayouexpectedbarbutno\"    script.py:   import os from dotenv import load_dotenv load_dotenv() from pyflarum import FlarumUser USER = FlarumUser( forum_url=\"https: discuss.flarum.org\", username=os.environ[\"username\"], password=os.environ[\"password\"] )   > Don't forget to exclude  .env in your  .gitignore , if you're using Git (in other words, don't be like me once)!  \ud83d\udcda Cached sessions: By default, pyFlarum uses the standard  Session object from Python's [requests](https: pypi.org/project/requests). However, it is possible to pass your own  Session object. A practical use case would be to use [requests_cache's](https: pypi.org/projects/requests_cache)  CachedSession object instead:   from requests_cache import CachedSession from pyflarum import FlarumUser USER = FlarumUser( forum_url=\"https: discuss.flarum.org\", session_object=CachedSession() )   The cache really makes a difference and can speed requests by up to 10x! But I decided to make it optional, as it is not ideal for frequent API calls (e. g. watching for notifications/mentions to respond to user's commands - yes, that's possible with [the commands and watch extensions](https: github.com/CWKevo/pyflarum/blob/main/tests/watch_for_commands.py  \ud83e\udde9 Extensions Similarly to [Flarum](https: discuss.flarum.org/t/extensions), pyFlarum also works around the concept of [extensions](https: cwkevo.github.io/pyflarum/docs/extensions/index.html). These can be imported and included in your  FlarumUser object as a list of extension classes:   from pyflarum import FlarumUser from pyflarum.extensions.flarum.core import Flarum_Likes USER = FlarumUser( forum_url=\"https: discuss.flarum.org\" extensions=[ Flarum_Likes.LikesExtension ] )   .    \ud83d\udc32 Dealing with type hints I really tried to make this work, but I couldn't. In case you haven't head about them, read [this](https: docs.python.org/3/library/typing.html). Basically, they help you read your code before it's run. The thing is, extensions work on principe of [monkey-patching](https: stackoverflow.com/questions/5626193/what-is-monkey-patching). When you create a  FlarumUser object with extensions, the mixins (classes of properties and functions) of that extensions are copied to the main  FlarumUser class (or others). And there is no way for your editor to handle this (or at least, I haven't found a way around this - if you do, that would be amazing). The only option for now is to type hint the mixins directly, to make your editor recognize also the functions and properties from the extension: Example:   from pyflarum import FlarumUser from pyflarum.extensions.flarum.core import Flarum_Approval USER = FlarumUser( forum_url=\"https: discuss.flarum.org\" extensions=[ Flarum_Approval.ApprovalExtension ] ) discussion = USER.get_discussion_by_id(1) discussion.isApproved    Note: The  Flarum_Approval extension contains only one mixin for discussions:  Flarum_Approval.ApprovalDiscussionFromNotificationMixin . Since this is a parent of  Discussion because of the [inheritance]( \u2b06-class-inheritance), you can type-hint just that for it to work (no  Union from [typing](https: docs.python.org/3/library/typing.html) is required). You can check the [extensions documentation](https: cwkevo.github.io/pyflarum/docs/extensions) for list of available mixins and extensions, or the [source code](https: github.com/CWKevo/pyflarum/tree/main/pyflarum/extensions).  \u2b06 Class Inheritance pyFlarum's inhertitance needed to be wrapped around Flarum's API, so that these two can work together. To understand this system, we need to first understand how Flarum's API works: Normally, there is an API route for multiple (bulk) object's data. You can further specify the ID to obtain the specific object's data. Let's say we want to fetch all discussions from the front page. We could do that by visiting  /api/discussions of your favourite Flarum forum. Here, we see a bunch of JSON data of discussions. We can pick one, and then visit  /api/discussions/:discussion_id to fetch specific discussion's JSON. By comparing the data from the bulk route ( /api/discussions ) and specific route ( /api/discussions/:discussion_id ), we can see that the specific route contains more detailed JSON information of the discussion. Specifically, this means that discussion from bulk contains just data for the first post, whereas the specific route contains all posts (for example). Usually, Flarum inherits the more detailed data's properties from the previous less detailed ones. This means that discussion from bulk might contain ID, type and a few attributes, such as the title of the discussion. So, the specific discussion contains all the data that discussion from bulk contains (ID, type, title .) + all the posts (which too only get referenced when there are many of them). Luckily, I have put my best efforts to make pyFlarum handle this for you. That's why there are multiple objects for each of Flarum's thingies. Here's an example inheritance structure for posts:   (contains) (is parent for) Posts >> PostFromBulk -> Post   Or (more complicated) notifications:   (contains) (contains) (inherits from) Notifications >> Notification >> PostFromNotification  Post (is parent for) (is parent for)    \ud83d\udcdc Example: Fetch all discussions from the front page:   for discussion in USER.all_discussions(): print(type(discussion     Note how the type is  DiscussionFromBulk instead of  Discussion ? That's because  DiscussionFromBulk doesn't contain full data like  Discussion does. The data gets limited for Flarum's purposes. For example, you don't need all posts in order to render the discussions at the front page - so Flarum omits the posts from the data. You need to make additional API call to fetch the full data (with posts):    Wrong: for discussion in USER.all_discussions(): for posts in discussion.get_posts(): print(post.url)      Correct: for discussion in USER.all_discussions(): full_discussion = discussion.get_full_data()  makes an additional API call to fetch  /api/discussions/:discussion_id for posts in full_discussion.get_posts(): print(post.url)    \ud83d\udc40 Included data That was the easy part of the inheritance system. It gets more complicated with the  included things. Each API call might contain an  included section with more detailed data for referenced objects. Let's examine a wild JSON spotted in the real world:   { \"data\": [ { \"type\": \"discussions\", \"id\": \"1\", \"attributes\": { \"title\": \"An example title\" }, \"relationships\": { \"firstPost\": { \"data\": { \"type\": \"posts\", \"id\": \"1\" } } } } ], \"included\": [ { \"type\": \"posts\", \"id\": \"1\", \"attributes\": { \"content\": \"Bla bla bla\" } } ] }   This is a simplified syntax of how might a JSON for  /api/discussions look like. We can see a discussion with ID  1 , that has a special  relationships array (or dictionary, if you're a Pythonista). This array contains a reference for the  firstPost (unsurprisingly, that's the first post of the discussion). The full data is in the  included section of the JSON, where we indeed can see a post object with the corresponding ID of  1 . Again, I put together what I could to make this work for you instead of you working for it. Whenever pyFlarum makes an API call to a top-level route such as  /api/discussions , obtaining a discussion from that will include the parent  included in that discussion as well. So now, whenever you would like to obtain a post from that discussion, the reference for that post is found in the  relationships array and then it gets recursively matched to the resulting  PostFromDiscussion in the  included section. From Flarum's side, this was done to eliminate frequent API calls and to save on the JSON's size. Including the full data would possibly make the JSON contain duplicates, if for example, all posts were made by the same user. This way, the user is included only once in the  included section, and we saved some bytes to transfer. People using paid mobile networks will be grateful to save some cents. You might be asking, why keep tossing the parent  included into every object? Well, from pyFlarum's side this was done to save on the amount of requests and to speed the package up. Of course, instead of looking things in  included , you could make a direct API call to retrieve the full data of the object you want. But this would slow things down drastically, when you're operating with large amounts of data at the same time (e. g. fetching all discussions and posts - you'd need to make separate API call for every post in order to obtain the data - this way, everything's already in  included ). This is very complicated, and I can't explain things, so it might be worthy checking the source code, if you care to learn more about how pyFlarum handles this."
},
{
"ref":"pyflarum.custom_types",
"url":1,
"doc":"Custom types for pyFlarum.  Types: -  AnyUser -  User ,  UserFromBulk ,  UserFromNotification -  AnyDiscussion -  Discussion ,  DiscussionFromBulk ,  DiscussionFromNotification -  AnyPost -  Post ,  PostFromBulk ,  PostFromNotification "
},
{
"ref":"pyflarum.datetime_conversions",
"url":2,
"doc":""
},
{
"ref":"pyflarum.datetime_conversions.flarum_to_datetime",
"url":2,
"doc":"Converts Flarum's datetime string to Python's datetime object. Doesn't convert if the parameter is already a datetime object. Flarum's datetime format is  %Y-%m-%dT%H:%M:%S%z ",
"func":1
},
{
"ref":"pyflarum.datetime_conversions.datetime_to_flarum",
"url":2,
"doc":"Converts Python's datetime object to Flarum's datetime string. Doesn't convert if the parameter is already a string. Flarum's datetime format is  %Y-%m-%dT%H:%M:%S%z ",
"func":1
},
{
"ref":"pyflarum.error_handler",
"url":3,
"doc":""
},
{
"ref":"pyflarum.error_handler.FlarumError",
"url":3,
"doc":"Generic class for all Flarum related errors."
},
{
"ref":"pyflarum.error_handler.MissingExtensionError",
"url":3,
"doc":"Missing pyFlarum extension error."
},
{
"ref":"pyflarum.error_handler.MissingExtensionWarning",
"url":3,
"doc":"Missing pyFlarum extension warning."
},
{
"ref":"pyflarum.error_handler.parse_request",
"url":3,
"doc":"",
"func":1
},
{
"ref":"pyflarum.error_handler.handle_errors",
"url":3,
"doc":"Handles Flarum & request related errors. Should be called on error only.",
"func":1
},
{
"ref":"pyflarum.extensions",
"url":4,
"doc":""
},
{
"ref":"pyflarum.extensions.ExtensionMixin",
"url":4,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.ExtensionMixin.get_dependencies",
"url":4,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.ExtensionMixin.mixin",
"url":4,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.absolutely_all",
"url":5,
"doc":""
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllFlarumUserMixin",
"url":5,
"doc":""
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllFlarumUserMixin.absolutely_all_users",
"url":5,
"doc":"A generator that yields  Users from entire forum, until there are  None left.  Filter compatible.",
"func":1
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllFlarumUserMixin.absolutely_all_posts",
"url":5,
"doc":"A generator that yields  Posts from entire forum, until there are  None left.  Filter compatible.",
"func":1
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllFlarumUserMixin.absolutely_all_discussions",
"url":5,
"doc":"A generator that yields  Discussions from entire forum, until there are  None left.  Filter compatible.",
"func":1
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllFlarumUserMixin.absolutely_all_notifications",
"url":5,
"doc":"A generator that yields all of your  Notifications , until there are  None left.  Filter compatible.",
"func":1
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllExtension",
"url":5,
"doc":"A pyFlarum extension. Allows you to fetch all specific data from a forum (e. g.: all discussions, all posts, etc.), until there are none left. Based on  Generator , that yields in a while loop, until no  next_link is present in the API."
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllExtension.get_dependencies",
"url":5,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.absolutely_all.AbsolutelyAllExtension.mixin",
"url":5,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.admin",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings",
"url":6,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.extensions.admin.MailSettings.data",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.type",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.id",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.attributes",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.fields",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mail",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mailgun",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mailgun_secret",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mailgun_domain",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.log",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.smtp",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mail_host",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mail_port",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mail_encryption",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mail_username",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.mail_password",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.sending",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.MailSettings.errors",
"url":6,
"doc":""
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin",
"url":6,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.enable_extension",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.disable_extension",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.clear_cache",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.update_forum_info",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.get_mail_settings",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.update_mail_settings",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.send_test_mail",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.update_appearance",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.upload_logo",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.remove_logo",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.upload_favicon",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.remove_favicon",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.update_custom_header",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.update_custom_footer",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.update_custom_css",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminFlarumUserMixin.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.admin.AdminExtension",
"url":6,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.admin.AdminExtension.get_dependencies",
"url":6,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminExtension.mixin",
"url":6,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminExtension.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminExtension.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminExtension.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminExtension.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.admin.AdminExtension.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.advanced_search",
"url":8,
"doc":""
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchFlarumUserMixin",
"url":8,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchFlarumUserMixin.get_user_by_username",
"url":8,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchFlarumUserMixin.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchFlarumUserMixin.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchFlarumUserMixin.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchFlarumUserMixin.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchFlarumUserMixin.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension",
"url":8,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension.get_dependencies",
"url":8,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension.mixin",
"url":8,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.advanced_search.AdvancedSearchExtension.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.commands",
"url":9,
"doc":""
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin",
"url":9,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin.is_mentioned_in",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin.parse_as_command",
"url":9,
"doc":"Parses a command from a string (e. g.: post's content). The result is list of arguments.  Example:   user.parse_command()  ",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsFlarumUserMixin.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension",
"url":9,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.get_dependencies",
"url":9,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.mixin",
"url":9,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.parse_as_command",
"url":9,
"doc":"Parses a command from a string (e. g.: post's content). The result is list of arguments.  Example:   user.parse_command()  ",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.commands.CommandsExtension.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.flarum",
"url":10,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings",
"url":11,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsUserFromBulkMixin",
"url":11,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsUserFromBulkMixin.canViewWarnings",
"url":11,
"doc":"Whether or not you can view the warnings of the user."
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsUserFromBulkMixin.canManageWarnings",
"url":11,
"doc":"Whether or not you are able to manage the user's warnings."
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsUserFromBulkMixin.canDeleteWarnings",
"url":11,
"doc":"Whether or not you can delete the user's warnings."
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsUserFromBulkMixin.visibleWarningCount",
"url":11,
"doc":"The amount of warnings that you can see that belong to the user."
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsExtension",
"url":11,
"doc":"https: extiverse.com/extension/askvortsov/flarum-moderator-warnings"
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsExtension.get_dependencies",
"url":11,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ModeratorWarnings.ModeratorWarningsExtension.mixin",
"url":11,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ReplyTemplates",
"url":12,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ReplyTemplates.ReplyTemplatesDiscussionFromBulkMixin",
"url":12,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ReplyTemplates.ReplyTemplatesDiscussionFromBulkMixin.replyTemplate",
"url":12,
"doc":"The reply template for the discussion."
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ReplyTemplates.ReplyTemplatesDiscussionFromBulkMixin.canManageReplyTemplates",
"url":12,
"doc":"Whether or not you are able to manage the discussion's reply templates."
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ReplyTemplates.ReplyTemplatesExtension",
"url":12,
"doc":"https: extiverse.com/extension/askvortsov/flarum-discussion-templates"
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ReplyTemplates.ReplyTemplatesExtension.get_dependencies",
"url":12,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Askvortsov_ReplyTemplates.ReplyTemplatesExtension.mixin",
"url":12,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Blomstra_Realtime",
"url":13,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Blomstra_Realtime.RealtimeDiscussionMixin",
"url":13,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Blomstra_Realtime.RealtimeDiscussionMixin.canViewWhoTypes",
"url":13,
"doc":"Whether or not you can view who is typing in real time."
},
{
"ref":"pyflarum.extensions.flarum.Blomstra_Realtime.RealtimeExtension",
"url":13,
"doc":"https: extiverse.com/extension/blomstra/realtime"
},
{
"ref":"pyflarum.extensions.flarum.Blomstra_Realtime.RealtimeExtension.get_dependencies",
"url":13,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Blomstra_Realtime.RealtimeExtension.mixin",
"url":13,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval",
"url":14,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalDiscussionFromNotificationMixin",
"url":14,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalDiscussionFromNotificationMixin.isApproved",
"url":14,
"doc":"Whether or not the discussion is approved."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalPostFromNotificationMixin",
"url":14,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalPostFromNotificationMixin.isApproved",
"url":14,
"doc":"Whether or not the post is approved."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalPostFromNotificationMixin.canApprove",
"url":14,
"doc":"Whether or not you are able to approve the post"
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalPostFromNotificationMixin.approve",
"url":14,
"doc":"Approve the post. Use  force to approve despite the post being approved already, and do not raise  FlarumError .",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalExtension",
"url":14,
"doc":"https: packagist.org/packages/flarum/approval"
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalExtension.get_dependencies",
"url":14,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Approval.ApprovalExtension.mixin",
"url":14,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags",
"url":15,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsForumMixin",
"url":15,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsForumMixin.canViewFlags",
"url":15,
"doc":"Whether or not you can view all the flags on the forum."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsForumMixin.flagCount",
"url":15,
"doc":"The total flagged post/discussion count (forum-wide)."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsForumMixin.guidelinesUrl",
"url":15,
"doc":"The URL of the forum's guidelines, if specified by the admin."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsPostFromNotificationMixin",
"url":15,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsPostFromNotificationMixin.canFlag",
"url":15,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsExtension",
"url":15,
"doc":"https: packagist.org/packages/flarum/flags"
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsExtension.get_dependencies",
"url":15,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Flags.FlagsExtension.mixin",
"url":15,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes",
"url":16,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesPostFromDiscussionMixin",
"url":16,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesPostFromDiscussionMixin.like",
"url":16,
"doc":"Likes a post.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesPostFromDiscussionMixin.unlike",
"url":16,
"doc":"Unlikes liked post.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesPostFromNotificationMixin",
"url":16,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesPostFromNotificationMixin.canLike",
"url":16,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesPostFromBulkMixin",
"url":16,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesPostFromBulkMixin.get_liked_by",
"url":16,
"doc":"Obtain the list of users that liked the post.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesExtension",
"url":16,
"doc":"https: packagist.org/packages/flarum/likes"
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesExtension.get_dependencies",
"url":16,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Likes.LikesExtension.mixin",
"url":16,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock",
"url":17,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockDiscussionFromNotificationMixin",
"url":17,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockDiscussionFromNotificationMixin.lock",
"url":17,
"doc":"Locks the discussion.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockDiscussionFromNotificationMixin.unlock",
"url":17,
"doc":"Unlocks the discussion.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockDiscussionFromBulkMixin",
"url":17,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockDiscussionFromBulkMixin.isLocked",
"url":17,
"doc":"Whether or not the discussion is locked."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockDiscussionFromBulkMixin.canLock",
"url":17,
"doc":"Whether or not you are able to lock the discussion."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockExtension",
"url":17,
"doc":"https: packagist.org/packages/flarum/lock"
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockExtension.get_dependencies",
"url":17,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Lock.LockExtension.mixin",
"url":17,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Markdown",
"url":18,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Markdown.ForumMixin",
"url":18,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Markdown.ForumMixin.markdown_mdarea",
"url":18,
"doc":"Whether or not the MDArea is enabled for markdown."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Markdown.ExampleExtension",
"url":18,
"doc":"https: packagist.org/packages/flarum/markdown"
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Markdown.ExampleExtension.get_dependencies",
"url":18,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Markdown.ExampleExtension.mixin",
"url":18,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky",
"url":19,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyDiscussionFromNotificationMixin",
"url":19,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyDiscussionFromNotificationMixin.stick",
"url":19,
"doc":"Stickies a discussion.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyDiscussionFromNotificationMixin.unstick",
"url":19,
"doc":"Unstickies a discussion.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyDiscussionFromBulkMixin",
"url":19,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyDiscussionFromBulkMixin.isSticky",
"url":19,
"doc":"Whether or not the discussion is stickied."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyDiscussionFromBulkMixin.canSticky",
"url":19,
"doc":"Whether or not you are able to stick this discussion."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyExtension",
"url":19,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyExtension.get_dependencies",
"url":19,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Sticky.StickyExtension.mixin",
"url":19,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions",
"url":20,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromNotificationMixin",
"url":20,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromNotificationMixin.follow",
"url":20,
"doc":"Follow the discussion and be notified of all new activity.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromNotificationMixin.unfollow",
"url":20,
"doc":"Unfollow the discussion, but be notified when someone mentions you.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromNotificationMixin.ignore",
"url":20,
"doc":"Ignore the discussion, never be mentioned. Note that this will also hide the discussion from  Discussions . Currently, the only ways to access ignored Flarum discussions that I am aware of are: 1. Accessing the discussion directly (by ID). 2. Using  pyflarum.flarum.core.filters.Filter (e. g.  Filter(query=\"is:ignored\") ).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin",
"url":20,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.subscription",
"url":20,
"doc":"Get the current subscription state of the discussion."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.follow",
"url":20,
"doc":"Follow the discussion and be notified of all new activity.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.unfollow",
"url":20,
"doc":"Unfollow the discussion, but be notified when someone mentions you.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsDiscussionFromBulkMixin.ignore",
"url":20,
"doc":"Ignore the discussion, never be mentioned. Note that this will also hide the discussion from  Discussions . Currently, the only ways to access ignored Flarum discussions that I am aware of are: 1. Accessing the discussion directly (by ID). 2. Using  pyflarum.flarum.core.filters.Filter (e. g.  Filter(query=\"is:ignored\") ).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsExtension",
"url":20,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsExtension.get_dependencies",
"url":20,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Subscriptions.SubscriptionsExtension.mixin",
"url":20,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend",
"url":22,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend.SuspendUserMixin",
"url":22,
"doc":"An user from  Users ."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend.SuspendUserMixin.canSuspend",
"url":22,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend.SuspendUserMixin.suspendedUntil",
"url":22,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend.SuspendUserMixin.suspend",
"url":22,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend.SuspendExtension",
"url":22,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend.SuspendExtension.get_dependencies",
"url":22,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Suspend.SuspendExtension.mixin",
"url":22,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag",
"url":23,
"doc":"A Flarum tag."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.data",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.type",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.id",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.attributes",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.name",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.description",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.slug",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.color",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.backgroundUrl",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.backgroundMode",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.icon",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.discussionCount",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.position",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.defaultSort",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.isChild",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.isHidden",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.lastPostedAt",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.canStartDiscussion",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.canAddToDiscussion",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.subscription",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.template",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.relationships",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.get_parent_tag",
"url":23,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.restrict_permissions",
"url":23,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.Tag.unrestrict_permissions",
"url":23,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsForumMixin",
"url":23,
"doc":"Forum JSON data"
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsForumMixin.canBypassTagCounts",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsForumMixin.minPrimaryTags",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsForumMixin.maxPrimaryTags",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsForumMixin.minSecondaryTags",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsForumMixin.maxSecondaryTags",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin",
"url":23,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.canTag",
"url":23,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.get_tags",
"url":23,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsDiscussionMixin.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsExtension",
"url":23,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsExtension.get_dependencies",
"url":23,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Flarum_Tags.TagsExtension.mixin",
"url":23,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer",
"url":24,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionNotificationMixin",
"url":24,
"doc":"A discussion from  BaseNotification "
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionNotificationMixin.hasBestAnswer",
"url":24,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionNotificationMixin.bestAnswerSetAt",
"url":24,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionNotificationMixin.hide",
"url":21,
"doc":"Hides the discussion. Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionNotificationMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionNotificationMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionNotificationMixin.delete",
"url":21,
"doc":"Deletes a discussion forever - this action is irreversible!",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin",
"url":24,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.canSelectBestAnswer",
"url":24,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerDiscussionMixin.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerExtension",
"url":24,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerExtension.get_dependencies",
"url":24,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_BestAnswer.BestAnswerExtension.mixin",
"url":24,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu",
"url":25,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin",
"url":25,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.canEditRecipients",
"url":25,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.canEditUserRecipients",
"url":25,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.canEditGroupRecipients",
"url":25,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuDiscussionMixin.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuUserMixin",
"url":25,
"doc":"An user from  Users ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuUserMixin.blocksPd",
"url":25,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuUserMixin.cannotBeDirectlyMessaged",
"url":25,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuExtension",
"url":25,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuExtension.get_dependencies",
"url":25,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Byobu.ByobuExtension.mixin",
"url":25,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge",
"url":26,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin",
"url":26,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.canMerge",
"url":26,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeDiscussionMixin.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeExtension",
"url":26,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeExtension.get_dependencies",
"url":26,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Merge.MergeExtension.mixin",
"url":26,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping",
"url":27,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin",
"url":27,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.fof_prevent_necrobumping",
"url":27,
"doc":"I have no idea what this does either, sorry."
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingDiscussionMixin.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingExtension",
"url":27,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingExtension.get_dependencies",
"url":27,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_PreventNecrobumping.PreventNecrobumpingExtension.mixin",
"url":27,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock",
"url":28,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock.SpamblockUserFromNotificationMixin",
"url":28,
"doc":"An user from  BaseNotification "
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock.SpamblockUserFromNotificationMixin.spamblock",
"url":28,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock.SpamblockUserMixin",
"url":28,
"doc":"An user that was fetched from the API."
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock.SpamblockUserMixin.canSpamblock",
"url":28,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock.SpamblockExtension",
"url":28,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock.SpamblockExtension.get_dependencies",
"url":28,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Spamblock.SpamblockExtension.mixin",
"url":28,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split",
"url":29,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin",
"url":29,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.canSplit",
"url":29,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitDiscussionMixin.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitExtension",
"url":29,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitExtension.get_dependencies",
"url":29,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_Split.SplitExtension.mixin",
"url":29,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio",
"url":30,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioForumMixin",
"url":30,
"doc":"Forum JSON data"
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioForumMixin.max_bio_length",
"url":30,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioFlarumUserMixin",
"url":30,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioFlarumUserMixin.update_user_bio",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioFlarumUserMixin.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioFlarumUserMixin.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioFlarumUserMixin.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioFlarumUserMixin.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioFlarumUserMixin.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioUserFromBulkMixin",
"url":30,
"doc":"An user from  Users ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioUserFromBulkMixin.bio",
"url":30,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioUserFromBulkMixin.canViewBio",
"url":30,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioUserFromBulkMixin.canEditBio",
"url":30,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioExtension",
"url":30,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioExtension.get_dependencies",
"url":30,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UserBio.UserBioExtension.mixin",
"url":30,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UsernameRequest",
"url":31,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_UsernameRequest.UsernameRequestUserMixin",
"url":31,
"doc":"An user from  Users ."
},
{
"ref":"pyflarum.extensions.flarum.FoF_UsernameRequest.UsernameRequestUserMixin.usernameHistory",
"url":31,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.FoF_UsernameRequest.UsernameRequestExtension",
"url":31,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.FoF_UsernameRequest.UsernameRequestExtension.get_dependencies",
"url":31,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.FoF_UsernameRequest.UsernameRequestExtension.mixin",
"url":31,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement",
"url":32,
"doc":"An achievement (Malago's Achievements extension)."
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.data",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.type",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.attributes",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.name",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.description",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.computation",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.points",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.icon",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.rectangle",
"url":32,
"doc":"No, I have no idea what this is either."
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.active",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.hidden",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.Achievement.new",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsForumMixin",
"url":32,
"doc":"Forum JSON data"
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsForumMixin.show_achievements_in_post_footer",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsForumMixin.show_achievements_in_user_card",
"url":32,
"doc":""
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin",
"url":32,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.update_settings",
"url":32,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.create_achievement",
"url":32,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.get_all_achievements",
"url":32,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsAdminFlarumUserMixin.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsExtension",
"url":32,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsExtension.get_dependencies",
"url":32,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.flarum.Malago_Achievements.AchievementsExtension.mixin",
"url":32,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.watch",
"url":33,
"doc":""
},
{
"ref":"pyflarum.extensions.watch.WatchFlarumUserMixin",
"url":33,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.extensions.watch.WatchFlarumUserMixin.watch_notifications",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchFlarumUserMixin.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchFlarumUserMixin.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchFlarumUserMixin.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchFlarumUserMixin.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchFlarumUserMixin.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.extensions.watch.WatchExtension",
"url":33,
"doc":"A base class for mixing in custom classes (extensions) into another classes.  Example extension code:   from typing import Type from pyflarum.extensions import ExtensionMixin from pyflarum.extensions.admin import AdminExtension from pyflarum.session import FlarumUser  Lowecase: AUTHOR = \"yourname\" NAME = \"extensionname\" ID = f\"{AUTHOR}-{NAME}\"  List of dependencies: SOFT_DEPENDENCIES = [AdminExtension]  uses methods from this extension, but can run without it HARD_DEPENCENDIES = []  I recommend to use the following naming pattern:    Mixin  Example: class ExampleFlarumUserMixin: @property def example(self):  ' Calling  FlarumUser( ).example would return this.  ' return \"Example\" ExampleFlarumUserMixin: Type[FlarumUser]  mimick class inheritance, without inheriting at runtime, acts just as a type hint class ExampleExtension(ExtensionMixin): def get_dependencies(self): return { \"soft\": SOFT_DEPENDENCIES, \"hard\": HARD_DEPENCENDIES } def mixin(self): super().mixin(self, FlarumUser, ExampleFlarumUserMixin)  "
},
{
"ref":"pyflarum.extensions.watch.WatchExtension.get_dependencies",
"url":33,
"doc":"This should return the following  dict :   { \"hard\": [ ,  ,  .], \"soft\": [ ,  ,  .] }   A dependency is anything that you can pass into  FlarumUser(extensions=[ .]) (e. g. an extension class).  Hard-dependencies: - Will raise an error when they're not found in the initialized  FlarumUser object. It is impossible for the extension to function without these.  Soft-dependencies: - Will raise just a warning. It is possible for the extension to function without these, although with limitations (such that some functions might be unavailable).",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchExtension.mixin",
"url":33,
"doc":"A function to mix-in/merge properties, methods, functions, etc . of one class into another. This skips all functions and properties starting with  __ (double underscore), unless  skip_protected is False. This sets/overwrites attributes of  class_to_patch to attributes of  class_to_mix_in (monkey-patch).  Example:   extension.mixin(myclass, pyflarum_class)  ",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchExtension.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchExtension.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchExtension.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchExtension.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.extensions.watch.WatchExtension.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.flarum",
"url":34,
"doc":""
},
{
"ref":"pyflarum.flarum.core",
"url":35,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.PreparedDiscussion",
"url":21,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.flarum.core.discussions.PreparedDiscussion.to_dict",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.PreparedDiscussion.post",
"url":21,
"doc":"Posts/creates the discussion. Raises  FlarumError or returns  False if it failed, otherwise the new  Discussion is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.PreparedDiscussion.create",
"url":21,
"doc":"Posts/creates the discussion. Raises  FlarumError or returns  False if it failed, otherwise the new  Discussion is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions",
"url":21,
"doc":"A data of multiple discussions fetched from the API."
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions.links",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions.first_link",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions.previous_link",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions.next_link",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions.data",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions.included",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.Discussions.get_discussions",
"url":21,
"doc":"All discussions from the  Discussions object.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification",
"url":21,
"doc":"A discussion from  BaseNotification "
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.get_full_data",
"url":21,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.data",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.type",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.id",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.attributes",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.title",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.slug",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.hide",
"url":21,
"doc":"Hides the discussion. Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.restore",
"url":21,
"doc":"Restores the discussion (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.unhide",
"url":21,
"doc":"Restores the discussion (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromNotification.delete",
"url":21,
"doc":"Deletes a discussion forever - this action is irreversible!",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk",
"url":21,
"doc":"A discussion from  Discussions ."
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.url",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.commentCount",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.participantCount",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.createdAt",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.lastPostedAt",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.lastPostNumber",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.lastReadPostNumber",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.canReply",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.canRename",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.canDelete",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.canHide",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.lastReadAt",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.isHidden",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.subscription",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.relationships",
"url":21,
"doc":""
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.get_author",
"url":21,
"doc":"Obtains the author of the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.get_first_post",
"url":21,
"doc":"Obtains the first post of the discussion. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.DiscussionFromBulk.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion",
"url":21,
"doc":"A Flarum discussion, obtained directly from the API by ID. This is the top-level discussion object that contains all the properties of a discussion, and inherits properties from all previous discussion-like objects. Learn more about inheritance [here](https: cwkevo.github.io/pyflarum/docs/ class-inheritance)"
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.included",
"url":21,
"doc":"Returns raw list of JSON included data.  Discussion.get_author() Learn more about included data [here](https: cwkevo.github.io/pyflarum/docs/ included-data)"
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.get_author",
"url":21,
"doc":"Obtains the discussion's author, AKA. the author of the post with number 1 in a discussion.  mode allows you to specify the mode that is used to determine whether or not the post is the first post of the discussion. -  'first_number' - checks if the number of the post is 1 - if yes, it fetches that post's author. -  Any - if anything other than  'first_number' is passed (e. g.  'first_user , but this can be anything), then this returns the author of the first post in the JSON. I am not sure how reliable is this, and whether or not the posts are actually ordered correctly in the API, so it's probably a good idea to also check if the number of the post is 1 - but then again, what if the first post gets removed?",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.get_posts",
"url":21,
"doc":"Returns a list of  pyflarum.flarum.core.posts.PostFromBulk objects. It might seem strange why this doesn't return  pyflarum.flarum.core.posts.PostFromDiscussion instead, but these posts are in fact identical to  pyflarum.flarum.core.posts.PostFromBulk , that's why they are returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.get_first_post",
"url":21,
"doc":"The  Discussion object does not have the first post's JSON data in it's own JSON. Because of Python's subclass inheritance, this function was included in  Discussion , but it does not work!  Alternative:   discussion = user.get_discussion_by_id(1) first_post = discussion.get_posts()[0]  ",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.get_last_posted_user",
"url":21,
"doc":"Obtains the user that posted the latest post in the discussion. It returns  pyflarum.flarum.core.users.UserFromNotification because it's JSON data matches the data of user from notification. This works by fetching it from the  _parent_included property.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.hide",
"url":21,
"doc":"Hides the discussion from the sight of other unprivileged users that are not worthy to view such thread.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.restore",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.unhide",
"url":21,
"doc":"Restores the discussion (unhides it), bringing it back to life.",
"func":1
},
{
"ref":"pyflarum.flarum.core.discussions.Discussion.delete",
"url":21,
"doc":"Scronches the discussion forever. This cannot be reverted. Use  force=True to attempt to delete the discussion even if the API states that you can't.",
"func":1
},
{
"ref":"pyflarum.flarum.core.filters",
"url":36,
"doc":""
},
{
"ref":"pyflarum.flarum.core.filters.Filter",
"url":36,
"doc":""
},
{
"ref":"pyflarum.flarum.core.filters.Filter.to_dict",
"url":36,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum",
"url":37,
"doc":"Forum JSON data"
},
{
"ref":"pyflarum.flarum.core.forum.Forum.data",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.type",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.id",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.attributes",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.title",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.description",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.showLanguageSelector",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.baseUrl",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.basePath",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.debug",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.apiUrl",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.welcomeTitle",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.welcomeMessage",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.themePrimaryColor",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.themeSecondaryColor",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.logoUrl",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.faviconUrl",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.headerHtml",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.footerHtml",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.allowSignUp",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.defaultRoute",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.canViewForum",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.canStartDiscussion",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.canSearchUsers",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.adminUrl",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.version",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.allowUsernameMentionFormat",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.relationships",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.forum.Forum.get_groups",
"url":37,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.forum.Forum.included",
"url":37,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.PreparedGroup",
"url":38,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.flarum.core.groups.PreparedGroup.to_dict",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.PreparedGroup.create",
"url":38,
"doc":"Creates the group. Returns the created  Group .",
"func":1
},
{
"ref":"pyflarum.flarum.core.groups.Groups",
"url":38,
"doc":"A data of multiple groups fetched from the API."
},
{
"ref":"pyflarum.flarum.core.groups.Groups.links",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Groups.first_link",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Groups.previous_link",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Groups.next_link",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Groups.data",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Groups.included",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Groups.get_groups",
"url":38,
"doc":"All groups from the  Groups object.",
"func":1
},
{
"ref":"pyflarum.flarum.core.groups.Group",
"url":38,
"doc":"A Flarum group."
},
{
"ref":"pyflarum.flarum.core.groups.Group.data",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.type",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.id",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.attributes",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.nameSingular",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.namePlural",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.color",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.icon",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.isHidden",
"url":38,
"doc":""
},
{
"ref":"pyflarum.flarum.core.groups.Group.edit",
"url":38,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.groups.Group.delete",
"url":38,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.groups.Group.get_groups",
"url":38,
"doc":"All groups from the  Groups object.",
"func":1
},
{
"ref":"pyflarum.flarum.core.notifications",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications",
"url":39,
"doc":"A data of multiple notifications fetched from the API."
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.links",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.first_link",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.previous_link",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.next_link",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.data",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.included",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.get_notifications",
"url":39,
"doc":"All notifications from the  Notifications object.",
"func":1
},
{
"ref":"pyflarum.flarum.core.notifications.Notifications.mark_all_as_read",
"url":39,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.notifications.Notification",
"url":39,
"doc":"Notification, that always has properties defined."
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.data",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.type",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.id",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.attributes",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.contentType",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.content",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.new_post_number",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.reply_number",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.createdAt",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.isRead",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.relationships",
"url":39,
"doc":""
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.from_user",
"url":39,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.get_subject",
"url":39,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.notifications.Notification.mark_as_read",
"url":39,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PreparedPost",
"url":40,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.flarum.core.posts.PreparedPost.to_dict",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PreparedPost.post",
"url":40,
"doc":"Posts/creates the post. Returns the created  Post .",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PreparedPost.create",
"url":40,
"doc":"Posts/creates the post. Returns the created  Post .",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.Posts",
"url":40,
"doc":"A data of multiple posts fetched from the API."
},
{
"ref":"pyflarum.flarum.core.posts.Posts.links",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.Posts.first_link",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.Posts.previous_link",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.Posts.next_link",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.Posts.data",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.Posts.included",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.Posts.get_posts",
"url":40,
"doc":"All posts from the  Posts object.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion",
"url":40,
"doc":"A post from  Discussion "
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.data",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.type",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.id",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.attributes",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.number",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.createdAt",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.contentType",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.contentHtml",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.hide",
"url":40,
"doc":"Hides the post. Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.restore",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.unhide",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.delete",
"url":40,
"doc":"Removes the post forever.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromDiscussion.edit",
"url":40,
"doc":"Edits the post.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification",
"url":40,
"doc":"A post from  Notification "
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.content",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.ipAddress",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.editedAt",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.canEdit",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.canDelete",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.canHide",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.relationships",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.url",
"url":40,
"doc":""
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.get_discussion",
"url":40,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.reply_to",
"url":40,
"doc":"Replies to this  Post with another  PreparedPost .",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.get_author",
"url":40,
"doc":"",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.edit",
"url":40,
"doc":"Edits the post.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.hide",
"url":40,
"doc":"Hides the post. Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.restore",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.unhide",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromNotification.delete",
"url":40,
"doc":"Removes the post forever.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromBulk",
"url":40,
"doc":"A post from  Posts ."
},
{
"ref":"pyflarum.flarum.core.posts.PostFromBulk.reply_to",
"url":40,
"doc":"Replies to this  Post with another  PreparedPost .",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromBulk.edit",
"url":40,
"doc":"Edits the post.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromBulk.hide",
"url":40,
"doc":"Hides the post. Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromBulk.restore",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromBulk.unhide",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.PostFromBulk.delete",
"url":40,
"doc":"Removes the post forever.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.Post",
"url":40,
"doc":"A Flarum group."
},
{
"ref":"pyflarum.flarum.core.posts.Post.reply_to",
"url":40,
"doc":"Replies to this  Post with another  PreparedPost .",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.Post.edit",
"url":40,
"doc":"Edits the post.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.Post.hide",
"url":40,
"doc":"Hides the post. Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.Post.restore",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.Post.unhide",
"url":40,
"doc":"Restores the post (unhides). Raises  FlarumError or returns  False if it failed, otherwise  True is returned.",
"func":1
},
{
"ref":"pyflarum.flarum.core.posts.Post.delete",
"url":40,
"doc":"Removes the post forever.",
"func":1
},
{
"ref":"pyflarum.flarum.core.users",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.Users",
"url":41,
"doc":"A data of multiple users fetched from the API."
},
{
"ref":"pyflarum.flarum.core.users.Users.links",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.Users.first_link",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.Users.previous_link",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.Users.next_link",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.Users.data",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.Users.included",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.Users.get_users",
"url":41,
"doc":"All users from the  Users object.",
"func":1
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification",
"url":41,
"doc":"An user from  BaseNotification "
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.data",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.type",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.id",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.attributes",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.username",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.email",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.isEmailConfirmed",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.displayName",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.avatarUrl",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromNotification.slug",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk",
"url":41,
"doc":"An user from  Users ."
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.joinTime",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.discussionCount",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.commentCount",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.canEdit",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.canEditCredentials",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.canEditGroups",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.canDelete",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.UserFromBulk.relationships",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.User",
"url":41,
"doc":"An user that was fetched from the API."
},
{
"ref":"pyflarum.flarum.core.users.User.foo",
"url":41,
"doc":""
},
{
"ref":"pyflarum.flarum.core.users.MyUser",
"url":41,
"doc":"Your user, contains full user data."
},
{
"ref":"pyflarum.session",
"url":7,
"doc":""
},
{
"ref":"pyflarum.session.FlarumSession",
"url":7,
"doc":""
},
{
"ref":"pyflarum.session.FlarumSession.authenticate",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumSession.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
},
{
"ref":"pyflarum.session.FlarumUser",
"url":7,
"doc":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict( kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)"
},
{
"ref":"pyflarum.session.FlarumUser.get_forum_data",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.get_discussion_by_id",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.get_post_by_id",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.all_discussions",
"url":7,
"doc":"Obtains all discussions from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.all_posts",
"url":7,
"doc":"Obtains all posts from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.all_users",
"url":7,
"doc":"Obtains all users from specific page by using  filter .",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.get_notifications",
"url":7,
"doc":"Obtains all notifications of your user.",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.mark_all_discussions_as_read",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.mark_all_notifications_as_read",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.get_groups",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.get_user_by_id",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.update_user_info",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.send_password_reset_email",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.update_preferences",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.change_email",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.upload_user_avatar",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.remove_user_avatar",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pyflarum.session.FlarumUser.api_urls",
"url":7,
"doc":"Simple, hardcoded  'key: value'  dict of Flarum's API routes for quick access. API routes reference (old): https: github.com/flarum/flarum.github.io/blob/20322c0e6011e4f304ae7e95f41594a0b086bc27/_docs/api.md"
}
]